
/****************************************************
 * ACM86xx driver
****************************************************/
#include "USER_Config.h"
#if defined(ACM86xxId1)

#define u8	uint8_t
#define u16	uint16_t

#define ACM_DBG_INFO(fmt,...)      os_printf("[ACM]"fmt, ##__VA_ARGS__)

//****Register_Table ******************
struct REG_TAB {
	u8 Address;
	u8 Data;
};

struct ADDR_TAB {
	u8 Pagh;
	u8 Addr;
};

/*******************************************************************************************************
Pagh:0 Addr:0x01
Bit Field 		Type 	Reset 	Description
-----------------------------------------------
7 	FAULT_CLR 	R/W 	0 		Once write this bit to 1, device will clear analog fault, this bit is auto
6-4 RESERVED 	R 		000 	These bits are reserved
3-1 FSW_SEL 	R/W 	000
	000: 384kHz
	001: 260kHz
	010: 480kHz
	011: 576kHz
	100: 768kHz
0 	PBTL 		R/W 	0 		0:BTL Mode,	1:PBTL Mode, PBTL can be set when device is in digital off state

Pagh:0 Addr:0x04
Bit Field 		Type 	Reset 	Description
-----------------------------------------------
7 	RST_REG 	R/W 	0 		0= Normal, 1= Reset Register
6 	RST_MOD 	R/W 	0 		0= Normal, 1: Reset Signal path
5 	CH_L_HIZ 	R/W 	0 		0= Normal State, 1= Change L channel鈥檚 output driver into Hi-Z state
4 	CH_R_HIZ 	R/W 	0 		0= Normal State, 1= Change R channel鈥檚 output driver into Hi-Z state
3 	MUTE_L 		R/W 	0 		0= Normal, 1= Mute L Channel
2 	MUTE_R 		R/W 	0 		0= Normal, 1= Mute R Channel
1-0 CTRL_STATE 	R/W 	00 		00: Digital Off, 01: Analog off, 10: Driver Off (Hiz), 11: Play

*********************************************************************************************************/
const struct REG_TAB sys_init[]=
{
  //==== initialization script ================
	{ 0x00, 0x00 },
		{ 0x04, 0x00 },
		{ 0xfc, 0x86 },
		{ 0xfd, 0x25 },	//8628S
		{ 0xfe, 0x15 },	//8628S
	{ 0x00, 0x01 },
		{ 0x02, 0x20 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },

#if defined(ACM25pId1_CS5038_8p4_18)
	//ClassH
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x0b },
		{ 0x14, 0x1c },	{ 0x15, 0x6d },	{ 0x16, 0xd4 },	{ 0x17, 0x0e },
		{ 0x10, 0x1e },	{ 0x11, 0x98 },	{ 0x12, 0x54 },	{ 0x13, 0x5d },
		{ 0x0c, 0x20 },	{ 0x0d, 0xc2 },	{ 0x0e, 0xd4 },	{ 0x0f, 0xac },
		{ 0x08, 0x22 },	{ 0x09, 0xed },	{ 0x0a, 0x54 },	{ 0x0b, 0xfb },
		{ 0x04, 0x25 },	{ 0x05, 0x17 },	{ 0x06, 0xd5 },	{ 0x07, 0x4a },
	{ 0x00, 0x0a },
		{ 0xfc, 0x27 },	{ 0xfd, 0x42 },	{ 0xfe, 0x55 },	{ 0xff, 0x99 },
		{ 0xf8, 0x29 },	{ 0xf9, 0x6c },	{ 0xfa, 0xd5 },	{ 0xfb, 0xe9 },
		{ 0xf4, 0x2b },	{ 0xf5, 0x97 },	{ 0xf6, 0x56 },	{ 0xf7, 0x38 },
		{ 0xf0, 0x2d },	{ 0xf1, 0xc1 },	{ 0xf2, 0xd6 },	{ 0xf3, 0x87 },
		{ 0xec, 0x2f },	{ 0xed, 0xec },	{ 0xee, 0x56 },	{ 0xef, 0xd6 },
		{ 0xe8, 0x32 },	{ 0xe9, 0x16 },	{ 0xea, 0xd7 },	{ 0xeb, 0x25 },
		{ 0xe4, 0x34 },	{ 0xe5, 0x41 },	{ 0xe6, 0x57 },	{ 0xe7, 0x74 },
		{ 0xe0, 0x36 },	{ 0xe1, 0x6b },	{ 0xe2, 0xd7 },	{ 0xe3, 0xc3 },
		{ 0xdc, 0x38 },	{ 0xdd, 0x96 },	{ 0xde, 0x58 },	{ 0xdf, 0x12 },
		{ 0xd8, 0x3a },	{ 0xd9, 0xc0 },	{ 0xda, 0xd8 },	{ 0xdb, 0x61 },
		{ 0xd4, 0x3c },	{ 0xd5, 0xeb },	{ 0xd6, 0x58 },	{ 0xd7, 0xb0 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },


#elif defined(ACM25pId1_CS5038_12_20)
	//ClassH CS5038 12V~20V
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x0b },
		{ 0x14, 0x28 },	{ 0x15, 0x9c },	{ 0x16, 0xe5 },	{ 0x17, 0xcb },
		{ 0x10, 0x2a },	{ 0x11, 0x6a },	{ 0x12, 0xfb },	{ 0x13, 0x62 },
		{ 0x0c, 0x2c },	{ 0x0d, 0x39 },	{ 0x0e, 0x10 },	{ 0x0f, 0xf9 },
		{ 0x08, 0x2e },	{ 0x09, 0x07 },	{ 0x0a, 0x26 },	{ 0x0b, 0x91 },
		{ 0x04, 0x2f },	{ 0x05, 0xd5 },	{ 0x06, 0x3c },	{ 0x07, 0x28 },
	{ 0x00, 0x0a },
		{ 0xfc, 0x31 },	{ 0xfd, 0xa3 },	{ 0xfe, 0x51 },	{ 0xff, 0xbf },
		{ 0xf8, 0x33 },	{ 0xf9, 0x71 },	{ 0xfa, 0x67 },	{ 0xfb, 0x56 },
		{ 0xf4, 0x35 },	{ 0xf5, 0x3f },	{ 0xf6, 0x7c },	{ 0xf7, 0xee },
		{ 0xf0, 0x37 },	{ 0xf1, 0x0d },	{ 0xf2, 0x92 },	{ 0xf3, 0x85 },
		{ 0xec, 0x38 },	{ 0xed, 0xdb },	{ 0xee, 0xa8 },	{ 0xef, 0x1c },
		{ 0xe8, 0x3a },	{ 0xe9, 0xa9 },	{ 0xea, 0xbd },	{ 0xeb, 0xb3 },
		{ 0xe4, 0x3c },	{ 0xe5, 0x77 },	{ 0xe6, 0xd3 },	{ 0xe7, 0x4b },
		{ 0xe0, 0x3e },	{ 0xe1, 0x45 },	{ 0xe2, 0xe8 },	{ 0xe3, 0xe2 },
		{ 0xdc, 0x40 },	{ 0xdd, 0x13 },	{ 0xde, 0xfe },	{ 0xdf, 0x79 },
		{ 0xd8, 0x41 },	{ 0xd9, 0xe2 },	{ 0xda, 0x14 },	{ 0xdb, 0x10 },
		{ 0xd4, 0x43 },	{ 0xd5, 0xb0 },	{ 0xd6, 0x29 },	{ 0xd7, 0xa7 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },

#elif defined(BZQ703)
	//==== ClassH =============================================
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x0b },
		{ 0x14, 0x28 },	{ 0x15, 0x9c },	{ 0x16, 0xe5 },	{ 0x17, 0xcb },
		{ 0x10, 0x2b },	{ 0x11, 0x52 },	{ 0x12, 0x06 },	{ 0x13, 0x2e },
		{ 0x0c, 0x2e },	{ 0x0d, 0x07 },	{ 0x0e, 0x26 },	{ 0x0f, 0x91 },
		{ 0x08, 0x30 },	{ 0x09, 0xbc },	{ 0x0a, 0x46 },	{ 0x0b, 0xf3 },
		{ 0x04, 0x33 },	{ 0x05, 0x71 },	{ 0x06, 0x67 },	{ 0x07, 0x56 },
	{ 0x00, 0x0a },
		{ 0xfc, 0x36 },	{ 0xfd, 0x26 },	{ 0xfe, 0x87 },	{ 0xff, 0xb9 },
		{ 0xf8, 0x38 },	{ 0xf9, 0xdb },	{ 0xfa, 0xa8 },	{ 0xfb, 0x1c },
		{ 0xf4, 0x3b },	{ 0xf5, 0x90 },	{ 0xf6, 0xc8 },	{ 0xf7, 0x7f },
		{ 0xf0, 0x3e },	{ 0xf1, 0x45 },	{ 0xf2, 0xe8 },	{ 0xf3, 0xe2 },
		{ 0xec, 0x40 },	{ 0xed, 0xfb },	{ 0xee, 0x09 },	{ 0xef, 0x45 },
		{ 0xe8, 0x43 },	{ 0xe9, 0xb0 },	{ 0xea, 0x29 },	{ 0xeb, 0xa7 },
		{ 0xe4, 0x46 },	{ 0xe5, 0x65 },	{ 0xe6, 0x4a },	{ 0xe7, 0x0a },
		{ 0xe0, 0x49 },	{ 0xe1, 0x1a },	{ 0xe2, 0x6a },	{ 0xe3, 0x6d },
		{ 0xdc, 0x4b },	{ 0xdd, 0xcf },	{ 0xde, 0x8a },	{ 0xdf, 0xd0 },
		{ 0xd8, 0x4e },	{ 0xd9, 0x84 },	{ 0xda, 0xab },	{ 0xdb, 0x33 },
		{ 0xd4, 0x51 },	{ 0xd5, 0x39 },	{ 0xd6, 0xcb },	{ 0xd7, 0x96 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
#elif defined(SG_P60)
//  ClassH	CS5038 FB1.0v Min 12v /Max 24v R2 51k
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x0b },
		{ 0x14, 0x28 },	{ 0x15, 0x9c },	{ 0x16, 0xe5 },	{ 0x17, 0xcb },
		{ 0x10, 0x2b },	{ 0x11, 0x52 },	{ 0x12, 0x06 },	{ 0x13, 0x2e },
		{ 0x0c, 0x2e },	{ 0x0d, 0x07 },	{ 0x0e, 0x26 },	{ 0x0f, 0x91 },
		{ 0x08, 0x30 },	{ 0x09, 0xbc },	{ 0x0a, 0x46 },	{ 0x0b, 0xf3 },
		{ 0x04, 0x33 },	{ 0x05, 0x71 },	{ 0x06, 0x67 },	{ 0x07, 0x56 },
	{ 0x00, 0x0a },
		{ 0xfc, 0x36 },	{ 0xfd, 0x26 },	{ 0xfe, 0x87 },	{ 0xff, 0xb9 },
		{ 0xf8, 0x38 },	{ 0xf9, 0xdb },	{ 0xfa, 0xa8 },	{ 0xfb, 0x1c },
		{ 0xf4, 0x3b },	{ 0xf5, 0x90 },	{ 0xf6, 0xc8 },	{ 0xf7, 0x7f },
		{ 0xf0, 0x3e },	{ 0xf1, 0x45 },	{ 0xf2, 0xe8 },	{ 0xf3, 0xe2 },
		{ 0xec, 0x40 },	{ 0xed, 0xfb },	{ 0xee, 0x09 },	{ 0xef, 0x45 },
		{ 0xe8, 0x43 },	{ 0xe9, 0xb0 },	{ 0xea, 0x29 },	{ 0xeb, 0xa7 },
		{ 0xe4, 0x46 },	{ 0xe5, 0x65 },	{ 0xe6, 0x4a },	{ 0xe7, 0x0a },
		{ 0xe0, 0x49 },	{ 0xe1, 0x1a },	{ 0xe2, 0x6a },	{ 0xe3, 0x6d },
		{ 0xdc, 0x4b },	{ 0xdd, 0xcf },	{ 0xde, 0x8a },	{ 0xdf, 0xd0 },
		{ 0xd8, 0x4e },	{ 0xd9, 0x84 },	{ 0xda, 0xab },	{ 0xdb, 0x33 },
		{ 0xd4, 0x51 },	{ 0xd5, 0x39 },	{ 0xd6, 0xcb },	{ 0xd7, 0x96 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },

#elif defined(MZ_200K)
		  // ClassH ======================================================
		{ 0x00, 0x00 },	{ 0x0a, 0x2f },	{ 0x00, 0x01 },	{ 0x03, 0x20 },	// ClassH GPIO 1
#if 1	// MinVol:7.4v, MaxVol:19v
		{ 0x00, 0x0b },
			{ 0x14, 0x19 },	{ 0x15, 0x0b },	{ 0x16, 0x6b },	{ 0x17, 0x92 },
			{ 0x10, 0x1b },	{ 0x11, 0xa9 },	{ 0x12, 0x71 },	{ 0x13, 0x47 },
			{ 0x0c, 0x1e },	{ 0x0d, 0x47 },	{ 0x0e, 0x76 },	{ 0x0f, 0xfc },
			{ 0x08, 0x20 },	{ 0x09, 0xe5 },	{ 0x0a, 0x7c },	{ 0x0b, 0xb1 },
			{ 0x04, 0x23 },	{ 0x05, 0x83 },	{ 0x06, 0x82 },	{ 0x07, 0x66 },
		{ 0x00, 0x0a },
			{ 0xfc, 0x26 },	{ 0xfd, 0x21 },	{ 0xfe, 0x88 },	{ 0xff, 0x1b },
			{ 0xf8, 0x28 },	{ 0xf9, 0xbf },	{ 0xfa, 0x8d },	{ 0xfb, 0xd0 },
			{ 0xf4, 0x2b },	{ 0xf5, 0x5d },	{ 0xf6, 0x93 },	{ 0xf7, 0x85 },
			{ 0xf0, 0x2d },	{ 0xf1, 0xfb },	{ 0xf2, 0x99 },	{ 0xf3, 0x3a },
			{ 0xec, 0x30 },	{ 0xed, 0x99 },	{ 0xee, 0x9e },	{ 0xef, 0xef },
			{ 0xe8, 0x33 },	{ 0xe9, 0x37 },	{ 0xea, 0xa4 },	{ 0xeb, 0xa3 },
			{ 0xe4, 0x35 },	{ 0xe5, 0xd5 },	{ 0xe6, 0xaa },	{ 0xe7, 0x58 },
			{ 0xe0, 0x38 },	{ 0xe1, 0x73 },	{ 0xe2, 0xb0 },	{ 0xe3, 0x0d },
			{ 0xdc, 0x3b },	{ 0xdd, 0x11 },	{ 0xde, 0xb5 },	{ 0xdf, 0xc2 },
			{ 0xd8, 0x3d },	{ 0xd9, 0xaf },	{ 0xda, 0xbb },	{ 0xdb, 0x77 },
			{ 0xd4, 0x40 },	{ 0xd5, 0x4d },	{ 0xd6, 0xc1 },	{ 0xd7, 0x2c },
#endif
		{ 0x00, 0x00 },	{ 0x0a, 0x2f },	{ 0x00, 0x01 },	{ 0x03, 0x20 },
		{ 0x00, 0x00 },	{ 0x0a, 0x2f },	{ 0x00, 0x01 },	{ 0x03, 0x20 },
		{ 0x00, 0x00 },	{ 0x0a, 0x2f },	{ 0x00, 0x01 },	{ 0x03, 0x20 },


#endif

/*
	//==== ClassD Control Registers =======================================
	{ 0x00, 0x01 },
		{ 0x01, 0x04 },	// ?
		{ 0x00, 0x00 },
		{ 0x11, 0x00 },	// 0x03->0x00=report fault not latched	报告 未锁定故障
		{ 0x02, 0x0 },	// yuan++  0 = 0db, 1=-0.5db, step=0.5db, max=32 = -15.5db	類比輸入增益
		{ 0x06, 0x30 },	// b0=0=48kHz, 1=48kHz, b1.2=00=high PLL, 01=middle PLL, 10=11=middle PLL
		{ 0x03, 0x05 },	// b1.0 = 101 = 180kHz
		{ 0x01, 0x84 },	// FSW:480k  BTL mode
		{ 0x04, 0x02 },	// b1.0 = 10 = Driver Off (Hiz)
//		{ 0x07, 0x03 },	// yuan++ I2S Word length 32bit
*/

#if defined(SG_P60)
//  ClassD Control Registers
	{ 0x00, 0x01 },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x06, 0x30 },
		{ 0x05, 0xce },
#if 0
		{ 0x03, 0x05 },	// 480k
		{ 0x01, 0x84 },
#else
		{ 0x03, 0x04 },	// 384k
		{ 0x01, 0x80 },
#endif
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x14, 0x25 },
		{ 0x15, 0x2e },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },

#elif defined(Acm86xxId1_8625P_LoPo_384_PBTL)
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },

#elif defined(YQ_DEMO)	// 8625P BTL
		{ 0x00, 0x01 },
			{ 0x01, 0x07 },
		{ 0x00, 0x00 },
			{ 0x11, 0x0b },
			{ 0x02, 0x00 },
			{ 0x06, 0x30 },
			{ 0x28, 0x00 },
			{ 0x05, 0xc6 },
			{ 0x03, 0x01 },
			{ 0x01, 0x80 },
			{ 0x00, 0x00 },
			{ 0x04, 0x02 },
		{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
			{ 0x00, 0x03 },
			{ 0x13, 0x1d },
		{ 0x00, 0x00 },
			{ 0x04, 0x03 },
#elif defined(Acm86xxId1_8625_TBL)
	//  ClassD Control Registers ACM8625
	{ 0x00, 0x01 },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },	//add
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },	//add
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },	//add
	#if 0
		{ 0x03, 0x05 },	// 480k
		{ 0x01, 0x84 },
	#else
		{ 0x03, 0x01 },	// 384k
		{ 0x01, 0x80 },
	#endif
	{ 0x00, 0x00 },	//add
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x00 },	{ 0x00, 0x03 },	{ 0x13, 0x1d },	{ 0x00, 0x00 },	// add
		{ 0x04, 0x03 },

#elif defined(GY_P10)
	//ClassD ACM8625S_384_LowPo
	{ 0x00, 0x01 },
		{ 0x01, 0x07 },
	{ 0x00, 0x00 },
		{ 0x11, 0x0b },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x80 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x00 },	{ 0x00, 0x03 }, { 0x13, 0x1d },	{ 0x00, 0x00 },
		{ 0x04, 0x03 },

#elif defined(Acm86xxId1_8628S_PTBL)
	//ClassD 8628S 384k_LowPo_PTBL
	{ 0x00, 0x01 },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x04 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#elif defined(Acm86xxId1_8628S_TBL)
	//ClassD 8628S 384k_LowPo_TBL
	{ 0x00, 0x01 },
		{ 0x01, 0x07 },
	{ 0x00, 0x00 },
		{ 0x11, 0x0b },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x80 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#elif defined(ZY004)
	//ClassD ACM8625P_LoPo_384
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },		//??
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },		//??
		{ 0x01, 0x07 },
	{ 0x00, 0x00 },
		{ 0x11, 0x0b },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },	// DRB Off	 ACM8625P 相容  bit2 需設為 1
		{ 0x03, 0x01 },
		{ 0x01, 0x80 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },

#elif defined(ACM8625P_LoPo_384_CS5038_1p2_13_20V_PBTL)
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },


#else	// 8625 BTL
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x06, 0x30 },
		{ 0x05, 0x86 },	//ACM8625P 相容  bit2 需設為 1
#if 1	// PWM Freq:384k
		{ 0x03, 0x04 },
		{ 0x01, 0x80 },
#else	// PWM Freq:480k
		{ 0x03, 0x05 },
		{ 0x01, 0x84 },
#endif
		{ 0x04, 0x02 },
		{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
//		{ 0x04, 0x03 },
#endif
};

//*********************************************************************************************************/
const struct REG_TAB sys_init2[]=
{
  //  initialization script
	{ 0x00, 0x00 },
		{ 0x04, 0x00 },
		{ 0xfc, 0x86 },
		{ 0xfd, 0x25 },	//8628S
		{ 0xfe, 0x15 },	//8628S
	{ 0x00, 0x01 },
		{ 0x02, 0x20 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },
	{ 0x00, 0x00 },

#if defined(ACM8625P_LoPo_384_CS5038_1p2_13_20V_PBTL)
	//Pre volume
	{ 0x00, 0x04 },
		{ 0x88, 0x00 },
		{ 0x89, 0xe2 },
		{ 0x8a, 0xc4 },
		{ 0x8b, 0x6b },
	//ClassH ACM8625P_LoPo_384_CS5038_1p2_13_20V_PBTL
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x0b },
		{ 0x14, 0x2b },	{ 0x15, 0xff },	{ 0x16, 0x4e },	{ 0x17, 0x46 },
		{ 0x10, 0x2d },	{ 0x11, 0x93 },	{ 0x12, 0xa1 },	{ 0x13, 0x2b },
		{ 0x0c, 0x2f },	{ 0x0d, 0x27 },	{ 0x0e, 0xf4 },	{ 0x0f, 0x0f },
		{ 0x08, 0x30 },	{ 0x09, 0xbc },	{ 0x0a, 0x46 },	{ 0x0b, 0xf3 },
		{ 0x04, 0x32 },	{ 0x05, 0x50 },	{ 0x06, 0x99 },	{ 0x07, 0xd8 },
	{ 0x00, 0x0a },
		{ 0xfc, 0x33 },	{ 0xfd, 0xe4 },	{ 0xfe, 0xec },	{ 0xff, 0xbc },
		{ 0xf8, 0x35 },	{ 0xf9, 0x79 },	{ 0xfa, 0x3f },	{ 0xfb, 0xa0 },
		{ 0xf4, 0x37 },	{ 0xf5, 0x0d },	{ 0xf6, 0x92 },	{ 0xf7, 0x85 },
		{ 0xf0, 0x38 },	{ 0xf1, 0xa1 },	{ 0xf2, 0xe5 },	{ 0xf3, 0x69 },
		{ 0xec, 0x3a },	{ 0xed, 0x36 },	{ 0xee, 0x38 },	{ 0xef, 0x4d },
		{ 0xe8, 0x3b },	{ 0xe9, 0xca },	{ 0xea, 0x8b },	{ 0xeb, 0x32 },
		{ 0xe4, 0x3d },	{ 0xe5, 0x5e },	{ 0xe6, 0xde },	{ 0xe7, 0x16 },
		{ 0xe0, 0x3e },	{ 0xe1, 0xf3 },	{ 0xe2, 0x30 },	{ 0xe3, 0xfa },
		{ 0xdc, 0x40 },	{ 0xdd, 0x87 },	{ 0xde, 0x83 },	{ 0xdf, 0xdf },
		{ 0xd8, 0x42 },	{ 0xd9, 0x1b },	{ 0xda, 0xd6 },	{ 0xdb, 0xc3 },
		{ 0xd4, 0x43 },	{ 0xd5, 0xb0 },	{ 0xd6, 0x29 },	{ 0xd7, 0xa7 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
	{ 0x00, 0x00 },
		{ 0x0a, 0x2f },
	{ 0x00, 0x01 },
		{ 0x03, 0x20 },
	{ 0x00, 0x00 },
		{ 0x27, 0x02 },
#endif

	//==== ClassD Control Registers =======================================
#if defined(ACM8625P_LoPo_384_CS5038_1p2_13_20V_PBTL)
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#elif defined(YQ_DEMO)	//8625P PBTL
	{ 0x00, 0x01 },
		{ 0x01, 0x07 },
	{ 0x00, 0x00 },
		{ 0x11, 0x0b },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x81 },
		{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
		{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#elif defined(DY_DT_K800)
//  ClassD Control Registers ACM8625
	{ 0x00, 0x01 },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x06, 0x30 },
		{ 0x05, 0xc6 },
#if 1	// PWM Freq:384k
		{ 0x03, 0x04 },
		{ 0x01, 0x80 },
#else	// PWM Freq:480k
		{ 0x03, 0x05 },
		{ 0x01, 0x84 },
#endif
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
		{ 0x04, 0x03 },


#elif defined(Acm86xxId2_8628S_PTBL)
	//ClassD 8628S 384k_LowPo_PTBL
	{ 0x00, 0x01 },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x04 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#elif	defined(ACM86xxId2_28_BTL)
		{ 0x00, 0x01 },		// 8628 | 8629	BTL
			{ 0x01, 0x00 },
		{ 0x00, 0x00 },
			{ 0x11, 0x03 },
			{ 0x06, 0x30 },
			{ 0x05, 0xCE },
			{ 0x03, 0x04 },
			{ 0x01, 0x80 },
			{ 0x04, 0x02 },
		{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },{ 0x00, 0x00 },	{ 0x00, 0x00 },
		{ 0x00, 0x03 },
			{ 0x14, 0xA5 },
			{ 0x15, 0x2e },
		{ 0x00, 0x00 },
			{ 0x04, 0x03 },
#elif defined(Acm86xxId2_8625P_LoPo_384_PBTL)
	{ 0x00, 0x00 },
		{ 0x0e, 0x01 },
	{ 0x00, 0x01 },
		{ 0x1a, 0x0b },
		{ 0x01, 0x00 },
	{ 0x00, 0x00 },
		{ 0x11, 0x03 },
		{ 0x02, 0x00 },
		{ 0x06, 0x30 },
		{ 0x28, 0x00 },
		{ 0x05, 0xc6 },
		{ 0x03, 0x01 },
		{ 0x01, 0x81 },
	{ 0x00, 0x00 },
		{ 0x04, 0x02 },
	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
	{ 0x00, 0x03 },
		{ 0x13, 0x1d },
	{ 0x00, 0x00 },
		{ 0x04, 0x03 },
#else
		{ 0x00, 0x00 },
			{ 0x0e, 0x01 },
		{ 0x00, 0x01 },
			{ 0x1a, 0x0b },
			{ 0x01, 0x00 },
		{ 0x00, 0x00 },
			{ 0x11, 0x03 },
			{ 0x06, 0x30 },
			{ 0x05, 0x86 },	//ACM8625P 相容  bit2 需設為 1
	#if 1	// PWM Freq:384k
			{ 0x03, 0x04 },
			{ 0x01, 0x80 },
	#else	// PWM Freq:480k
			{ 0x03, 0x05 },
			{ 0x01, 0x84 },
	#endif
			{ 0x04, 0x02 },
			{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },	{ 0x00, 0x00 },
//			{ 0x04, 0x03 },
#endif
};

typedef enum eq_enum {
	Parametric = 0,	//PEQ
	LowShelf = 1,
	HighShelf = 2,
	LowPass = 3,
	HighPass = 4,
	BankPass = 5,
	BankStop = 6,
	butterworthsLP = 7,
	butterworthsHP = 8,
	BesselLP = 9,
	BesselHP = 10,
	ToneControl = 11,

	AllPass = 12,
	Notch = 13,
	ChebyshevLP = 14,
	ChebyshevHP = 15,
} IIR_TYPE_t;

//*****************************************************
void ACM_I2C_Init()
{
	SDAIN_MODE = GPIO_INOUT;
	gpio_config_new(SCL_IO, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_PERI_NONE);
	gpio_config_new(SDA1, GPIO_OUTPUT, GPIO_PULL_UP, GPIO_PERI_NONE);
}

//**** ACM8625 driver ******************
#ifndef	ACM86xxId2
	#define ACM86xxId2	0
#endif
uint8_t	ACM862xWId=0;
uint8_t	ACM862x_IIC_ADDR[2]={ACM86xxId1,ACM86xxId2};
// 8625,8629:(4.7k=0x2C)(15k=0x2D)(47k=0x2E)(120k=0x2F);	8628:(4.7k=0x14)(15k=0x15)(47k=0x16)(120k=0x17)
//**************************************************
uint8_t ACM_REPORT()
{
	if(ACM862x_IIC_ADDR[ACM862xWId] ==0)	return 1;
	ACM_I2C_Init();	//0805 add
	static u8 ErrReport=2;
	u8 reg[5];
	I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x00,0x00);	// 設定頁碼

	/****PAGH:0  REG:0x05 FUNCTION ************************************************
	Bit Field 		Type 	Reset 	Description
	7 AGL_BP 		R/W 	0 		0: Enable AGL	1: Bypass AGL
	6 DRB_BP 		R/W 	0 		0: Enable DRB	1: Bypass DRB
	5-4 RESERVED 	R 		0 		This bit is reserved
	3 POST_EQ_BP 	R/W 	0 		0: Enable Post-EQ	1: Bypass Post-EQ
	2 RESREVED 		R 		0 		This bit is reserved
	1 SUB_CH_BP 	R/W 	1 		0: Enable Sub Channel Processing	1: Bypass Sub Channel Processing
	0 PROCESSING_BP R/W 	0 		0: Enable audio effect tuning	1: Bypass all audio effect tuning
	*******************************************************************************/
	reg[0] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x05);
	reg[1] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x17);
	reg[2] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x18);
	reg[3] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x19);

	reg[4] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x04);

	if((reg[1]|reg[2]|reg[3])==0){
		if(ErrReport){
			ErrReport--;
			I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x00,0x00);	// 設定頁碼
			I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x04,0x03);	// Play
			ACM_DBG_INFO("== Ok.. Reg04:%02X  Reg05:%02X\n",I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x04),reg[0]);
		}
		return  0;
	}else{
		ErrReport = reg[1]+reg[2]+reg[3];
		I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x00,0x00);	// 設定頁碼
		reg[4] = I2C_ReadA8D8(ACM862x_IIC_ADDR[ACM862xWId], 0x01);
		reg[4] |= 0x80;
		I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x01,reg[4]);	//bit7=1 clear ErrReport
#if 1
		ACM_DBG_INFO("== Id:%d Inf Reg0x17,18,19: %02X %02X %02X\n",ACM862xWId, reg[1],reg[2],reg[3]);
		if(reg[1]){
			if(reg[1]&0x01)	ACM_DBG_INFO("!!! CH1 over current fault\n");
			if(reg[1]&0x02)	ACM_DBG_INFO("!!! CH2 over current fault\n");
			if(reg[1]&0x04)	ACM_DBG_INFO("!!! CH1 speaker DC fault\n");
			if(reg[1]&0x08)	ACM_DBG_INFO("!!! CH2 speaker DC fault\n");
			if(reg[1]&0x10)	ACM_DBG_INFO("!!! PVDD under voltage fault\n");
			if(reg[1]&0x20)	ACM_DBG_INFO("!!! PVDD over voltage fault\n");
			if(reg[1]&0x40)	ACM_DBG_INFO("!!! Over temperature shutdown\n");
		}
		if(reg[2]&0x04)	ACM_DBG_INFO("!!! Clock fault report\n");
		if(reg[3]){
			if(reg[3]&0x01)	ACM_DBG_INFO("!!! Over temperature warning\n");
			if(reg[3]&0x02)	ACM_DBG_INFO("!!! Channel 1 clipping\n");
			if(reg[3]&0x04)	ACM_DBG_INFO("!!! Channel 2 clipping\n");
		}
#endif
		//------------------------------------------------------------------
//		I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x00,0x00);	// 設定頁碼
//		I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId],0x04,0x00);	// Digital Off
	}
	return 1;
}

/*******************************************************
 * os_delay_ms... refer to your own os driver implement
 *******************************************************/
void ACM8625_init()
{
	ACM_I2C_Init();	//0805 add
	//================================================================
	for(uint8_t di=0; di<2; di++){
		if(ACM862x_IIC_ADDR[di]){
			ACM862xWId = di;
			SetI2CAddr(ACM862x_IIC_ADDR[ACM862xWId]);
			Start();									//发送起始命令
			SendData((ACM862x_IIC_ADDR[ACM862xWId]<<1)&0xFE);	//发送设备地址+写命令
			uint8_t ack = RecvACK();
			Stop();
			if(ack==0){
				ACM_DBG_INFO("== ID%d.ACM86xx Discovery  addr:%02X...\n",di,ACM862x_IIC_ADDR[ACM862xWId]);
				if(di==0){
					u16 len = (sizeof(sys_init)/sizeof(sys_init[0]));
					for(u16 i=0; i<len; i++){
						I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId], sys_init[i].Address,sys_init[i].Data);
					}
					MainBoardDAmp = 1;
				}else if(di==1){
					u16 len = (sizeof(sys_init2)/sizeof(sys_init2[0]));
					for(u16 i=0; i<len; i++){
						I2C_WriteA8D8(ACM862x_IIC_ADDR[ACM862xWId], sys_init2[i].Address,sys_init2[i].Data);
					}
					MainBoardDAmp = 2;
				}
				//==== float L2L, R2L, L2R, R2R  -110 ~ +48db ===============
//				ACM86_InputMixer(0,-110,-110,0);
				ACM86_DRB_ONOFF(0);
				ACM86_PEQ_ONOFF(1);
				ACM_REPORT();
				ACMIIR_ReSend(di);
			}else{
				ACM_DBG_INFO("xx ID%d.ACM86xx_ can't find addr:%02X\n",di,ACM862x_IIC_ADDR[ACM862xWId]);
				ACM862x_IIC_ADDR[ACM862xWId]=0;
			}
		}
	}
	ACM_DBG_INFO("== MainBoardDAmp:%d ====\n",MainBoardDAmp);
    ACM862xWId = 0;
    SetI2CAddr(ACM862x_IIC_ADDR[ACM862xWId]);
}

//*********************************************************************************************************************
ACM_SET ACM_Set[2]={
	  {{{0,   30, 700,   0},{0,   63, 700,  0},{0,   80, 700, 0},{0,  160, 700, 0},{0,  315, 700, 0},	// LCh EQ0~5
		{0,  400, 700,   0},{0,  630, 700,  0},{0, 1250, 700, 0},{0, 1600, 700, 0},{0, 2500, 700, 0},	// LCh EQ6~10
		{0, 3150, 700,   0},{0, 5000, 700,  0},{0, 6300, 700, 0},{0, 8000, 700, 0},{0,16000, 700, 0},	// LCh EQ10~15
		{0,20000, 700,   0},{0,20000, 700,  0},{0,20000, 700, 0},{0,20000, 700, 0},{0,20000, 700, 0},	// LCh PEQ0~5
		{0,   80, 700,   0},{0,  360, 700,  0},	// DRB Low 	EQ 0~1
		{0,   80, 700,   0},{0,  360, 700,  0},	// DRB High	EQ 0~1
		// R CH
		{0,   30, 700,   0},{0,   63, 700,  0},{0,   80, 700, 0},{0,  160, 700, 0},{0,  315, 700, 0},	// RCh EQ0~5
		{0,  400, 700,   0},{0,  630, 700,  0},{0, 1250, 700, 0},{0, 1600, 700, 0},{0, 2500, 700, 0},	// RCh EQ6~10
		{0, 3150, 700,   0},{0, 5000, 700,  0},{0, 6300, 700, 0},{0, 8000, 700, 0},{0,16000, 700, 0},	// RLCh EQ10~15
		{0,20000, 700,   0},{0,20000, 700,  0},{0,20000, 700, 0},{0,20000, 700, 0},{0,20000, 700, 0},	// RCh PEQ0~5
		{0,   80, 700,   0},{0,  360, 700,  0},		// DRB Low 	EQ 0~1
		{0,   80, 700,   0},{0,  360, 700,  0}},	// DRB High	EQ 0~1
		//	DrbOnOff	DrbLowGain	DrbHighGain	LR_Mix	ClassDGaie	InGaie
		1,			-30,		-10, 		1,		29.5f,		0.f},
	  {{{0,   30, 700,   0},{0,   63, 700,  0},{0,   80, 700, 0},{0,  160, 700, 0},{0,  315, 700, 0},	// LCh EQ0~5
		{0,  400, 700,   0},{0,  630, 700,  0},{0, 1250, 700, 0},{0, 1600, 700, 0},{0, 2500, 700, 0},	// LCh EQ6~10
		{0, 3150, 700,   0},{0, 5000, 700,  0},{0, 6300, 700, 0},{0, 8000, 700, 0},{0,16000, 700, 0},	// LCh EQ10~15
		{0,20000, 700,   0},{0,20000, 700,  0},{0,20000, 700, 0},{0,20000, 700, 0},{0,20000, 700, 0},	// LCh PEQ0~5
		{0,   80, 700,   0},{0,  360, 700,  0},	// DRB Low 	EQ 0~1
		{0,   80, 700,   0},{0,  360, 700,  0},	// DRB High	EQ 0~1
		// R CH
		{0,   30, 700,   0},{0,   63, 700,  0},{0,   80, 700, 0},{0,  160, 700, 0},{0,  315, 700, 0},	// RCh EQ0~5
		{0,  400, 700,   0},{0,  630, 700,  0},{0, 1250, 700, 0},{0, 1600, 700, 0},{0, 2500, 700, 0},	// RCh EQ6~10
		{0, 3150, 700,   0},{0, 5000, 700,  0},{0, 6300, 700, 0},{0, 8000, 700, 0},{0,16000, 700, 0},	// RLCh EQ10~15
		{0,20000, 700,   0},{0,20000, 700,  0},{0,20000, 700, 0},{0,20000, 700, 0},{0,20000, 700, 0},	// RCh PEQ0~5
		{0,   80, 700,   0},{0,  360, 700,  0},		// DRB Low 	EQ 0~1
		{0,   80, 700,   0},{0,  360, 700,  0}},	// DRB High	EQ 0~1
		//	DrbOnOff	DrbLowGain	DrbHighGain	LR_Mix	ClassDGaie	InGaie
		0,				-30,		-10, 		0,		0.f,		0.f}
};
ACM_SET ACM_SetR[2];

//****************************
void ACMIIR_ReSend(uint8_t id)	//20230730 edit
{
	ACM_SetR[id].ClassDGaie = 100.f;
	ACM_SetR[id].InGaie = 100.f;
	ACM_SetR[id].DrbHighGain = 0xFF;
	ACM_SetR[id].DrbLowGain = 0xFF;
	ACM_SetR[id].DrbOnOff = 0xFF;
	ACM_SetR[id].LR_Mix = 0xFF;

	for(uint8_t i=0; i<AcmEnd; i++)	ACM_SetR[id].EQ[i].freq = 0xFFFF;
	UpComputerRW = 0;	// 更新上位機
};


//****************************
uint8_t ACM_main()
{
	if(ACM862x_IIC_ADDR[ACM862xWId] ==0)	return 0;
	ACM_I2C_Init();	//0805 add
	uint8_t ACM_Busy = 0;
	fl2hex V1,V2,V3;
	Send_Group = EQ_Mode;
	Send_RW = UpComputerRW;
	Send_Id1 = Acm86Pid;
	Send_Id2 = 0;
	Send_Val4 = 0;
	V2.f = 0;
	V3.f = 0;
	//=============================================
	if(ACM_SetR[ACM862xWId].DrbOnOff != ACM_Set[ACM862xWId].DrbOnOff || \
			ACM_SetR[ACM862xWId].LR_Mix != ACM_Set[ACM862xWId].LR_Mix || \
			ACM_SetR[ACM862xWId].DrbLowGain != ACM_Set[ACM862xWId].DrbLowGain || \
			ACM_SetR[ACM862xWId].DrbHighGain != ACM_Set[ACM862xWId].DrbHighGain || \
			ACM_SetR[ACM862xWId].ClassDGaie != ACM_Set[ACM862xWId].ClassDGaie || \
			ACM_SetR[ACM862xWId].InGaie != ACM_Set[ACM862xWId].InGaie){

		ACM_SetR[ACM862xWId].DrbOnOff = ACM_Set[ACM862xWId].DrbOnOff;
		ACM_SetR[ACM862xWId].LR_Mix = ACM_Set[ACM862xWId].LR_Mix;
		ACM_SetR[ACM862xWId].DrbLowGain = ACM_Set[ACM862xWId].DrbLowGain;
		ACM_SetR[ACM862xWId].DrbHighGain = ACM_Set[ACM862xWId].DrbHighGain;
		ACM_SetR[ACM862xWId].ClassDGaie = ACM_Set[ACM862xWId].ClassDGaie;
		ACM_SetR[ACM862xWId].InGaie = ACM_Set[ACM862xWId].InGaie;

		Send_Val41 = (ACM862xWId+1);
		Send_Val42 = ACM_Set[ACM862xWId].DrbOnOff;
		Send_Val42 |= (ACM_Set[ACM862xWId].LR_Mix<<1);
		Send_Val43 = ACM_Set[ACM862xWId].DrbLowGain;
		Send_Val44 = ACM_Set[ACM862xWId].DrbHighGain;
		V1.f = ACM_Set[ACM862xWId].ClassDGaie;
		V2.f = ACM_Set[ACM862xWId].InGaie;

		ACM86_DRB_ONOFF(ACM_Set[ACM862xWId].DrbOnOff);
		ACM_DRB_SET(ACM_Set[ACM862xWId].DrbLowGain, ACM_Set[ACM862xWId].DrbHighGain);
		if(ACM_Set[ACM862xWId].LR_Mix){
#ifdef ZY_OA_001
			ACM86_InputMixer(0, 0, 0, 0);
#else
			ACM86_InputMixer(-6, -6, -6, -6);
#endif
		}else{
			//L2L, R2L, L2R, R2R
			ACM86_InputMixer(0, -110, -110, 0);
		}
		ACM_ClassGaie(ACM_Set[ACM862xWId].ClassDGaie, ACM_Set[ACM862xWId].InGaie);
		Send_Id2 = 25;
	}else{
		//**** EQ SET　*********************************************
		uint8_t i=AcmEnd;
		static uint8_t f=0;
		while(i--){
			if(++f >=AcmEnd) f=0;
//			CMD_DBG_INFO("====== f: %d\n", f);
			if(ACM_SetR[ACM862xWId].EQ[f].type != ACM_Set[ACM862xWId].EQ[f].type || \
					ACM_SetR[ACM862xWId].EQ[f].freq != ACM_Set[ACM862xWId].EQ[f].freq || \
					ACM_SetR[ACM862xWId].EQ[f].Q != ACM_Set[ACM862xWId].EQ[f].Q || \
					ACM_SetR[ACM862xWId].EQ[f].gain != ACM_Set[ACM862xWId].EQ[f].gain){
				ACM_SetR[ACM862xWId].EQ[f].type = ACM_Set[ACM862xWId].EQ[f].type;
				ACM_SetR[ACM862xWId].EQ[f].freq = ACM_Set[ACM862xWId].EQ[f].freq;
				ACM_SetR[ACM862xWId].EQ[f].Q = 	 ACM_Set[ACM862xWId].EQ[f].Q;
				ACM_SetR[ACM862xWId].EQ[f].gain = ACM_Set[ACM862xWId].EQ[f].gain;
#if 1
				ACM_EQ_SET(ACM_Set[ACM862xWId].EQ[f].type, f, ACM_Set[ACM862xWId].EQ[f].freq, \
						ACM_Set[ACM862xWId].EQ[f].Q, ACM_Set[ACM862xWId].EQ[f].gain);
#endif
			//	ACM_DBG_INFO("== ACM EQ %d: %d  %d  %d  %d\n", f, ACM_Set.EQ[f].type,ACM_Set.EQ[f].freq, ACM_Set.EQ[f].Q, ACM_Set.EQ[f].gain);
				V1.f = ((float)ACM_Set[ACM862xWId].EQ[f].freq);
				V2.f = ((float)ACM_Set[ACM862xWId].EQ[f].Q/1000);		// Q
				V3.f = ((float)ACM_Set[ACM862xWId].EQ[f].gain/10);  	// gain
				Send_Val42 = ACM_Set[ACM862xWId].EQ[f].type;
				if(f<24){
					Send_Val41 = 1;
					Send_Id2 = f+1;
				}else{
					Send_Val41 = 2;
					Send_Id2 = f-23;
				}
				break;	// 更新一筆 跳出
			}
	//		f++;
		}
	}
	//======================================
	if(Send_Id2){
		Send_Val1 = V1.h;
		Send_Val2 = V2.h;
		Send_Val3 = V3.h;
		SendUpComp(SendBuff, 32);
//		ACM_DBG_INFO("===== ID1:%d  ID2:%d\n", Send_Id1,Send_Id2);
		ACM_Busy = 1;
	}
	return	ACM_Busy;
}

#endif


        
